{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Assignment 2","text":"<p>There are 16 questions in all, 7 of which are tagged as [PY].  You are required to submit solutions to only 10 questions, 5 of which should have been tagged as [PY].</p> <p>Solutions to the questions tagged as [PY] shall be a python function.  Other questions are more conceptual in nature, and their solutions may be an algorithm/ pseudocode/ python function, as per your discretion.</p> <p>For submission details, click here.</p>"},{"location":"#question-1","title":"Question 1","text":"<p>Given the following undirected graph, perform a BFS as well as DFS starting from vertex \\(A\\). List the order in which the vertices are visited.</p> <p>\\(\\{A-B,\\; A-C,\\; B-D,\\; C-D,\\; D-E\\}\\)</p>"},{"location":"#question-2","title":"Question 2","text":"<p>Given the following directed graph, algorithmically determine if it is a DAG. If it is not, explain why.</p> <p>\\(\\{A\\to B,\\; B\\to C,\\; C\\to A,\\; B\\to D\\}\\)</p>"},{"location":"#question-3","title":"Question 3","text":"<p>Given the following DAG, algorithmically perform a topological sort.  </p> <p>\\(\\{A\\to B,\\; A\\to C,\\; B\\to D,\\; C\\to D\\}\\)</p>"},{"location":"#question-4-py","title":"Question 4 [PY]","text":"<p>Given a weighted vertex graph \\(G(V,E)\\), a start node \\(s\\) and a target sum \\(\\sigma\\).</p> <p>Write an algorithm, or equivalently a python program (WAP) to inspect if there is a path from \\(s\\) such that adding up all the vertex weights along the path, equals the target sum.</p> <p>Note: \\(\\forall v \\in V\\; \\exists v.w\\) that represents vertex weights.</p>"},{"location":"#question-5","title":"Question 5","text":"<p>WAP to traverse a binary tree using BFS.  Illustrate with necessary examples.</p>"},{"location":"#question-6-py","title":"Question 6 [PY]","text":"<p>Given two binary trees, \\(A,B\\), WAP to compute a merge operation defined as follows:</p> <p>Imagine that one is put on to cover the other; some nodes overlap, while others don\u2019t.  The merge rule states that for each position in the binary tree, if two nodes overlap, the value of the merged node is their sum; otherwise, it\u2019s the value of not null node. E.g.</p> <p></p>"},{"location":"#question-7","title":"Question 7","text":"<p>If the following paths completely describe a given undirected graph, show one possible order of nodes visited through BFS.</p> <p>\\(M-N-O-P-Q\\) \\(N-Q-M-R\\)</p>"},{"location":"#question-8","title":"Question 8","text":"<p>Given a binary tree, \\(B\\) find its min, max and average depths.</p> <p>PS: Depth of a tree is defined by the distance of leaf nodes from the root, not that of any intermediary nodes.</p>"},{"location":"#question-9-py","title":"Question 9 [PY]","text":"<p>Given an image \\(M\\in\\mathbb{Z}^{H\\times W}\\) represented as a grid (or matrix) of \\(H\\times W\\) of integers, where \\(m_{ij}\\) represents the pixel value of \\(i\\)-th row, \\(j\\)-th column.</p> <ol> <li> <p>WAP to flood-fill colour \\(\\kappa\\) starting at pixel    at \\(r\\)-th row and \\(c\\)-th column.</p> </li> <li> <p>Reflect on the relative merits of using BFS/DFS for    the process.</p> </li> </ol> <p>Flood Fill</p> <ul> <li>Flood fill is a process to change the colour of a   contiguous region, by starting with a given source   pixel and expanding along the neighbours until a   boundary is hit.</li> <li>Region is defined by colour of the start pixel.</li> <li>Neighbours shares a boundary (either vertically or   horizontally).</li> <li>A neighbour with colour different than that of the   start pixel is deemed to be a boundary; it\u2019s colour   is left untouched!</li> </ul> <p>LeetCode #733</p>"},{"location":"#question-10","title":"Question 10","text":"<p>Given an undirected graph \\(G(V,E)\\) without self-loops, and a pair \\((s,d)\\) of source and destination vertices, determine if a path between them exists in the graph.</p>"},{"location":"#question-11-py","title":"Question 11 [PY]","text":"<p>Evaluate a Boolean Binary Tree</p> <p>Given a full binary tree \\(B\\) such that,</p> <ul> <li>Leaf nodes bear binary truth values, i.e. <code>True</code> or   <code>False</code>; and </li> <li>Non leaf nodes bear values that represent logic   gates, namely <code>AND</code> or <code>OR</code>.</li> </ul> <p>WAP to evaluate the boolean binary tree \\(B\\) and return the result.</p> <p></p>"},{"location":"#question-12-py","title":"Question 12 [PY]","text":"<p>Island Perimeter</p> <p>Given a binary rectangular grid \\(M\\in\\{0,1\\}^{H\\times W}\\) with \\(H\\) rows and \\(W\\) columns, where each pixel \\(m_{ij}\\) represents either \\(0\\) for water or \\(1\\) for land.  Assume that</p> <ol> <li>There\u2019s exactly one island (contiguously connected    land cells);</li> <li>Pixels are connected either vertically or    horizontally but not diagonally; and</li> <li>There are no lakes.</li> </ol> <p>WAP to determine the perimeter of the island!</p> <p>LeetCode #463</p>"},{"location":"#question-13-py","title":"Question 13 [PY]","text":"<p>Given \\(N\\) courses labelled \\(\\{0,\\ldots,N-1\\}\\) and a list of prerequisites \\(R\\) such that the courses \\(R[i]\\equiv\\{a_i,b_i,\\ldots\\}\\) are required to be completed before enrolling for \\(i\\)-th course.</p> <p>WAP to determine if all the \\(N\\) courses can be completed successfully by a candidate.  If so, also determine one of the feasible ordering of courses.</p> <p>Examples</p> <ol> <li>\\(N=2\\), \\(R=[\\emptyset,\\{0\\}]\\) means that course \\(1\\)    requires course \\(0\\) as pre-requisite.  Hence, it is    possible to complete the courses, in the following    order: \\([0,1]\\).</li> <li>\\(N=2\\), \\(R=[\\{1\\},\\{0\\}]\\). Here, the requirement is    \\(1\\) before \\(0\\); and also \\(0\\) before \\(1\\).  This,    hence, is impossible.</li> </ol>"},{"location":"#question-14","title":"Question 14","text":"<p>Given a DAG \\(G(V,E)\\), WAP to determine the list of ancestors for each node.</p>"},{"location":"#question-15-py","title":"Question 15 [PY]","text":"<p>There are \\(N\\) cities, connected by flights.  Given the list of flights \\(F\\equiv\\{(s_i,d_i,p_i):0&lt;i\\leqslant N\\}\\) so that \\(i\\)-th flight connects the source city \\(s_i\\) to destination city \\(d_i\\) for a cost-price of \\(p_i\\).</p> <p>Given \\(A,B,k\\), WAP to determine the cheapest price to connect city \\(A\\) to city \\(B\\) with maximum \\(k\\) stops.</p> <p></p> <p>Examples (Optimal paths marked in red)</p> <ol> <li>\\(N=4, F\\equiv\\{ (0,1,100), (1,2,100), (2,0,100),    (2,3,200) \\}, A=0, B=3, k=1\\)    Result: \\(700\\)</li> <li>\\(N=3, F\\equiv \\{ (0,1,100), (1,2,100), (0,2,500) \\},    A=0, B=2, k=1\\)    Result: \\(200\\)</li> <li>\\(N=3, F\\equiv \\{ (0,1,100), (1,2,100), (0,2,500) \\},    A=0, B=2, k=0\\)    Result: \\(500\\)</li> </ol>"},{"location":"#question-16","title":"Question 16","text":"<p>There\u2019s a dungeon arranged as a grid of \\(N\\times M\\) rectangular rooms.</p> <p>\\(T\\in\\mathbb{Z}^{N\\times M}\\) represents for each room \\((i,j)\\), a threshold of minimum time \\(t_{ij}\\) starting from which a move into it may be initiated.</p> <p>Move is allowed only between two adjacent rooms that share a common vertical or horizontal wall, and each move takes 1 unit time duration.</p> <p>WAP to start from room \\((0,0)\\) and finally determine the minimum time required to reach the room \\((N-1,M-1)\\).</p> <p>Examples</p> <ol> <li>\\(T=[[0,4],[4,4]]\\)    Result: \\(6\\)    Explanation: \\(t=4: (0,0)\\to(1,0)\\); \\(t=5: (1,0)\\to(1,1)\\).</li> <li>\\(T=[[0,0,0],[0,0,0]]\\)    Result: \\(3\\)    Explanation: \\(t=0: (0,0)\\to(1,0)\\); \\(t=1: (1,0)\\to(1,1)\\); \\(t=1: (1,1)\\to(1,1)\\).</li> <li>\\(T=[[0,1],[1,2]]\\)    Result: \\(3\\)    Explanation: \\(t=1: (0,0)\\to(1,0)\\); \\(t=2: (1,0)\\to(1,1)\\).</li> </ol> <p>LeetCode #3341</p>"},{"location":"#submission-details","title":"Submission Details","text":"<p>[TODO]</p>"},{"location":"#glossary","title":"Glossary","text":""},{"location":"#loop","title":"Loop","text":"<p>An edge from a vertex to its own self.</p>"},{"location":"#binary-tree","title":"Binary Tree","text":"<p>A directed graph, where</p> <ul> <li>There\u2019s a fixed start node called root;</li> <li>Each node may have upto two children; and</li> <li>The node with no children is called a leaf.</li> </ul>"},{"location":"#full-binary-tree","title":"Full Binary Tree","text":"<p>A binary tree where each node has either two or no children</p>"},{"location":"#dag","title":"DAG","text":"<p>(Directed Acyclic Graph)</p> <p>A directed graph, where there are no back-edges.</p>"},{"location":"solutions-desc/","title":"Descriptive Solutions","text":"<ul> <li>Roll No: </li> <li>Name: </li> <li>Group:</li> <li>Email (@thapar.edu):</li> </ul>"},{"location":"solutions/","title":"Solutions","text":""},{"location":"solutions/#solutions","title":"<code>solutions</code>","text":"<p>Modules:</p> Name Description <code>example</code> <code>q01VertexOrder</code> <code>q02IsDagP</code> <code>q03TopologicalSort</code> <code>q04IsPathSumP</code> <code>q05BinaryTreeBfs</code> <code>q06MergeBinaryTrees</code> <code>q07ListBfsOrder</code> <code>q08BinaryTreeDepthStats</code> <code>q09FloodFill</code> <code>q10ExistsPathP</code> <code>q11EvalBooleanBinaryTreeP</code> <code>q12GetIslandPerimeter</code> <code>q13FulfilProgramP</code> <code>q14GetAllAncestors</code> <code>q15GetCheapestFlight</code> <code>q16DungeonCrossingTimeMin</code> <p>Attributes:</p> Name Type Description <code>Bbt</code> <p>Enumeration for constants in a Boolean Binary Tree.</p> <code>Flight</code> <p>Flight DataType. </p> <code>Graph</code> <p>Graph DataType. </p> <code>meta</code> <p>Details to be filled in by student before submission.</p>"},{"location":"solutions/#solutions--question-1","title":"Question 1","text":""},{"location":"solutions/#solutions--question-2","title":"Question 2","text":""},{"location":"solutions/#solutions--question-3","title":"Question 3","text":""},{"location":"solutions/#solutions--question-4-py","title":"Question 4 [PY]","text":""},{"location":"solutions/#solutions--question-5","title":"Question 5","text":""},{"location":"solutions/#solutions--question-6-py","title":"Question 6 [PY]","text":""},{"location":"solutions/#solutions--question-7","title":"Question 7","text":""},{"location":"solutions/#solutions--question-8","title":"Question 8","text":""},{"location":"solutions/#solutions--question-9-py","title":"Question 9 [PY]","text":""},{"location":"solutions/#solutions--question-10","title":"Question 10","text":""},{"location":"solutions/#solutions--question-11-py","title":"Question 11 [PY]","text":""},{"location":"solutions/#solutions--question-12-py","title":"Question 12 [PY]","text":""},{"location":"solutions/#solutions--question-13-py","title":"Question 13 [PY]","text":""},{"location":"solutions/#solutions--question-14","title":"Question 14","text":""},{"location":"solutions/#solutions--question-15-py","title":"Question 15 [PY]","text":""},{"location":"solutions/#solutions--question-16","title":"Question 16","text":""},{"location":"solutions/#solutions.Bbt","title":"<code>Bbt = Enum('Bbt', 'False,True,OR,AND')</code>  <code>module-attribute</code>","text":"<p>Enumeration for constants in a Boolean Binary Tree.</p> <p>This is just a fancy way of assigning the following constants, without polluting the global namespace,</p> <pre><code>Bbt.False = 0    # constant\nBbt.True = 1     # constant\nBbt.OR = 2       # constant\nBbt.AND = 3      # constant\n</code></pre>"},{"location":"solutions/#solutions.Flight","title":"<code>Flight = namedtuple('Flight', 's,d,p')</code>  <code>module-attribute</code>","text":"<p>Flight DataType. </p> <p>Essentially a namedtuple with members accessible as attributes, i.e. <code>F.s</code>, <code>F.d</code> and <code>F.p</code>.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <p>Source City.</p> required <code>d</code> <p>Destination City.</p> required <code>p</code> <p>Cost Price of the flight.</p> required"},{"location":"solutions/#solutions.Graph","title":"<code>Graph = namedtuple('Graph', 'V,E')</code>  <code>module-attribute</code>","text":"<p>Graph DataType. </p> <p>Essentially a namedtuple with members accessible as attributes.  So that <code>G.V</code> and <code>G.E</code> represent list of verts and adjacency respectively.</p>"},{"location":"solutions/#solutions.meta","title":"<code>meta = NS(rollNo='', name='', group='', email='')</code>  <code>module-attribute</code>","text":"<p>Details to be filled in by student before submission.</p>"},{"location":"solutions/example/","title":"Example","text":""},{"location":"solutions/example/#solutions.example","title":"<code>solutions.example</code>","text":"<p>Functions:</p> Name Description <code>add_one</code> <p>Add 1 unit to number and return.</p> <p>Attributes:</p> Name Type Description <code>Number</code> <p>Data Type for numbers includes both fixed and</p>"},{"location":"solutions/example/#solutions.example.Number","title":"<code>Number = int | float</code>  <code>module-attribute</code>","text":"<p>Data Type for numbers includes both fixed and floating-point representations.</p>"},{"location":"solutions/example/#solutions.example.add_one","title":"<code>add_one(number)</code>","text":"<p>Add 1 unit to number and return.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Number</code> <p>A number to be incremented by one.</p> required"},{"location":"solutions/q01VertexOrder/","title":"q01VertexOrder","text":""},{"location":"solutions/q01VertexOrder/#solutions.q01VertexOrder","title":"<code>solutions.q01VertexOrder</code>","text":""},{"location":"solutions/q01VertexOrder/#solutions.q01VertexOrder--question-1","title":"Question 1","text":"<p>Given the following undirected graph, perform a BFS as well as DFS starting from vertex \\(A\\). List the order in which the vertices are visited.</p> <p>\\(\\{A-B,\\; A-C,\\; B-D,\\; C-D,\\; D-E\\}\\)</p> <p>Functions:</p> Name Description <code>q01VertexOrder</code> <p>Args:</p>"},{"location":"solutions/q01VertexOrder/#solutions.q01VertexOrder.q01VertexOrder","title":"<code>q01VertexOrder(G)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Graph resolves into <code>G.V</code> and <code>G.E</code>.</p> required"},{"location":"solutions/q01VertexOrder/#solutions.q01VertexOrder.q01VertexOrder--using-bfs","title":"Using BFS","text":"<p>Write your comment here.</p>"},{"location":"solutions/q01VertexOrder/#solutions.q01VertexOrder.q01VertexOrder--using-dfs","title":"Using DFS","text":"<p>Write your comment here.</p>"},{"location":"solutions/q02IsDagP/","title":"q02IsDagP","text":""},{"location":"solutions/q02IsDagP/#solutions.q02IsDagP","title":"<code>solutions.q02IsDagP</code>","text":""},{"location":"solutions/q02IsDagP/#solutions.q02IsDagP--question-2","title":"Question 2","text":"<p>Given the following directed graph, algorithmically determine if it is a DAG. If it is not, explain why.</p> <p>\\(\\{A\\to B,\\; B\\to C,\\; C\\to A,\\; B\\to D\\}\\)</p> <p>Functions:</p> Name Description <code>q02IsDagP</code> <p>Args:</p>"},{"location":"solutions/q02IsDagP/#solutions.q02IsDagP.q02IsDagP","title":"<code>q02IsDagP(G)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Graph resolves into <code>G.V</code> and <code>G.E</code>.</p> required"},{"location":"solutions/q03TopologicalSort/","title":"q03TopologicalSort","text":""},{"location":"solutions/q03TopologicalSort/#solutions.q03TopologicalSort","title":"<code>solutions.q03TopologicalSort</code>","text":""},{"location":"solutions/q03TopologicalSort/#solutions.q03TopologicalSort--question-3","title":"Question 3","text":"<p>Given the following DAG, algorithmically perform a topological sort.  </p> <p>\\(\\{A\\to B,\\; A\\to C,\\; B\\to D,\\; C\\to D\\}\\)</p> <p>Functions:</p> Name Description <code>q03TopologicalSort</code> <p>Args:</p>"},{"location":"solutions/q03TopologicalSort/#solutions.q03TopologicalSort.q03TopologicalSort","title":"<code>q03TopologicalSort(G)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Graph resolves into <code>G.V</code> and <code>G.E</code>.</p> required"},{"location":"solutions/q04IsPathSumP/","title":"q04IsPathSumP","text":""},{"location":"solutions/q04IsPathSumP/#solutions.q04IsPathSumP","title":"<code>solutions.q04IsPathSumP</code>","text":""},{"location":"solutions/q04IsPathSumP/#solutions.q04IsPathSumP--question-4-py","title":"Question 4 [PY]","text":"<p>Given a weighted vertex graph \\(G(V,E)\\), a start node \\(s\\) and a target sum \\(\\sigma\\).</p> <p>Write an algorithm, or equivalently a python program (WAP) to inspect if there is a path from \\(s\\) such that adding up all the vertex weights along the path, equals the target sum.</p> <p>Note: \\(\\forall v \\in V\\; \\exists v.w\\) that represents vertex weights.</p> <p>Functions:</p> Name Description <code>q04IsPathSumP</code> <p>Args:</p>"},{"location":"solutions/q04IsPathSumP/#solutions.q04IsPathSumP.q04IsPathSumP","title":"<code>q04IsPathSumP(G, s, targetSum)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Graph resolves into <code>G.V</code> and <code>G.E</code>.</p> required <code>s</code> <code>int</code> <p>The start node.</p> required <code>targetSum</code> <code>int</code> <p>The target sum.</p> required"},{"location":"solutions/q05BinaryTreeBfs/","title":"q05BinaryTreeBfs","text":""},{"location":"solutions/q05BinaryTreeBfs/#solutions.q05BinaryTreeBfs","title":"<code>solutions.q05BinaryTreeBfs</code>","text":""},{"location":"solutions/q05BinaryTreeBfs/#solutions.q05BinaryTreeBfs--question-5","title":"Question 5","text":"<p>WAP to traverse a binary tree using BFS.  Illustrate with necessary examples.</p> <p>Functions:</p> Name Description <code>q05BinaryTreeBfs</code> <p>Args:</p>"},{"location":"solutions/q05BinaryTreeBfs/#solutions.q05BinaryTreeBfs.q05BinaryTreeBfs","title":"<code>q05BinaryTreeBfs(B, s)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>B</code> <code>Graph</code> <p>Graph resolves into <code>G.V</code> and <code>G.E</code>.  Guaranteed to represent a binary tree.</p> required <code>s</code> <code>int</code> <p>The root node.</p> required"},{"location":"solutions/q06MergeBinaryTrees/","title":"q06MergeBinaryTrees","text":""},{"location":"solutions/q06MergeBinaryTrees/#solutions.q06MergeBinaryTrees","title":"<code>solutions.q06MergeBinaryTrees</code>","text":""},{"location":"solutions/q06MergeBinaryTrees/#solutions.q06MergeBinaryTrees--question-6-py","title":"Question 6 [PY]","text":"<p>Given two binary trees, \\(A,B\\), WAP to compute a merge operation defined as follows:</p> <p>Imagine that one is put on to cover the other; some nodes overlap, while others don\u2019t.  The merge rule states that for each position in the binary tree, if two nodes overlap, the value of the merged node is their sum; otherwise, it\u2019s the value of not null node. E.g.</p> <p></p> <p>Functions:</p> Name Description <code>q06MergeBinaryTrees</code> <p>Args:</p>"},{"location":"solutions/q06MergeBinaryTrees/#solutions.q06MergeBinaryTrees.q06MergeBinaryTrees","title":"<code>q06MergeBinaryTrees(A, B)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>A</code> <code>Graph</code> <p>Graph resolves into <code>G.V</code> and <code>G.E</code>.  Guaranteed to be a binary tree.</p> required <code>B</code> <code>Graph</code> <p>Graph resolves into <code>G.V</code> and <code>G.E</code>.  Guaranteed to be a binary tree.</p> required"},{"location":"solutions/q07ListBfsOrder/","title":"q07ListBfsOrder","text":""},{"location":"solutions/q07ListBfsOrder/#solutions.q07ListBfsOrder","title":"<code>solutions.q07ListBfsOrder</code>","text":""},{"location":"solutions/q07ListBfsOrder/#solutions.q07ListBfsOrder--question-7","title":"Question 7","text":"<p>If the following paths completely describe a given undirected graph, show one possible order of nodes visited through BFS.</p> <p>\\(M-N-O-P-Q\\) \\(N-Q-M-R\\)</p> <p>Functions:</p> Name Description <code>q07ListBfsOrder</code> <p>Args:</p>"},{"location":"solutions/q07ListBfsOrder/#solutions.q07ListBfsOrder.q07ListBfsOrder","title":"<code>q07ListBfsOrder(vPaths)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>vPaths</code> <code>List[List[int]]</code> <p>List of paths. Each path is a list of vertex indices.</p> required"},{"location":"solutions/q08BinaryTreeDepthStats/","title":"q08BinaryTreeDepthStats","text":""},{"location":"solutions/q08BinaryTreeDepthStats/#solutions.q08BinaryTreeDepthStats","title":"<code>solutions.q08BinaryTreeDepthStats</code>","text":""},{"location":"solutions/q08BinaryTreeDepthStats/#solutions.q08BinaryTreeDepthStats--question-8","title":"Question 8","text":"<p>Given a binary tree, \\(B\\) find its min, max and average depths.</p> <p>PS: Depth of a tree is defined by the distance of leaf nodes from the root, not that of any intermediary nodes.</p> <p>Functions:</p> Name Description <code>q08BinaryTreeDepthStats</code> <p>Args:</p>"},{"location":"solutions/q08BinaryTreeDepthStats/#solutions.q08BinaryTreeDepthStats.q08BinaryTreeDepthStats","title":"<code>q08BinaryTreeDepthStats(B, s)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>B</code> <code>Graph</code> <p>Graph resolves into <code>G.V</code> and <code>G.E</code>.</p> required <code>s</code> <code>int</code> <p>The root node.</p> required"},{"location":"solutions/q09FloodFill/","title":"q09FloodFill","text":""},{"location":"solutions/q09FloodFill/#solutions.q09FloodFill","title":"<code>solutions.q09FloodFill</code>","text":""},{"location":"solutions/q09FloodFill/#solutions.q09FloodFill--question-9-py","title":"Question 9 [PY]","text":"<p>Given an image \\(M\\in\\mathbb{Z}^{H\\times W}\\) represented as a grid (or matrix) of \\(H\\times W\\) of integers, where \\(m_{ij}\\) represents the pixel value of \\(i\\)-th row, \\(j\\)-th column.</p> <ol> <li> <p>WAP to flood-fill colour \\(\\kappa\\) starting at pixel    at \\(r\\)-th row and \\(c\\)-th column.</p> </li> <li> <p>Reflect on the relative merits of using BFS/DFS for    the process.</p> </li> </ol> <p>Flood Fill</p> <ul> <li>Flood fill is a process to change the colour of a   contiguous region, by starting with a given source   pixel and expanding along the neighbours until a   boundary is hit.</li> <li>Region is defined by colour of the start pixel.</li> <li>Neighbours shares a boundary (either vertically or   horizontally).</li> <li>A neighbour with colour different than that of the   start pixel is deemed to be a boundary; it\u2019s colour   is left untouched!</li> </ul> <p>Functions:</p> Name Description <code>q09FloodFill</code> <p>Args:</p>"},{"location":"solutions/q09FloodFill/#solutions.q09FloodFill.q09FloodFill","title":"<code>q09FloodFill(M, k, r, c)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>M</code> <code>List[List[int]]</code> <p>A list of \\(H\\) lists of \\(W\\) integer values each representing colour at pixel \\((i,j)\\).</p> required <code>k</code> <code>int</code> <p>Target colour.</p> required <code>r</code> <code>int</code> <p>Row of the start pixel.</p> required <code>c</code> <code>int</code> <p>Col of the start pixel.</p> required"},{"location":"solutions/q10ExistsPathP/","title":"q10ExistsPathP","text":""},{"location":"solutions/q10ExistsPathP/#solutions.q10ExistsPathP","title":"<code>solutions.q10ExistsPathP</code>","text":""},{"location":"solutions/q10ExistsPathP/#solutions.q10ExistsPathP--question-10","title":"Question 10","text":"<p>Given an undirected graph \\(G(V,E)\\) without self-loops, and a pair \\((s,d)\\) of source and destination vertices, determine if a path between them exists in the graph.</p> <p>Functions:</p> Name Description <code>q10ExistsPathP</code> <p>Args:</p>"},{"location":"solutions/q10ExistsPathP/#solutions.q10ExistsPathP.q10ExistsPathP","title":"<code>q10ExistsPathP(G, s, d)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Graph resolves into <code>G.V</code> and <code>G.E</code>.</p> required <code>s</code> <code>int</code> <p>Index of the source vertex.</p> required <code>d</code> <code>int</code> <p>Index of the destination vertex.</p> required"},{"location":"solutions/q11EvalBooleanBinaryTreeP/","title":"q11EvalBooleanBinaryTreeP","text":""},{"location":"solutions/q11EvalBooleanBinaryTreeP/#solutions.q11EvalBooleanBinaryTreeP","title":"<code>solutions.q11EvalBooleanBinaryTreeP</code>","text":""},{"location":"solutions/q11EvalBooleanBinaryTreeP/#solutions.q11EvalBooleanBinaryTreeP--question-11-py","title":"Question 11 [PY]","text":"<p>Evaluate a Boolean Binary Tree</p> <p>Given a full binary tree \\(B\\) such that,</p> <ul> <li>Leaf nodes bear binary truth values, i.e. <code>True</code> or   <code>False</code>; and </li> <li>Non leaf nodes bear values that represent logic   gates, namely <code>AND</code> or <code>OR</code>.</li> </ul> <p>WAP to evaluate the boolean binary tree \\(B\\) and return the result.</p> <p></p> <p>See also: Bbt</p> <p>Functions:</p> Name Description <code>q11EvalBooleanBinaryTreeP</code> <p>Args:</p>"},{"location":"solutions/q11EvalBooleanBinaryTreeP/#solutions.q11EvalBooleanBinaryTreeP.q11EvalBooleanBinaryTreeP","title":"<code>q11EvalBooleanBinaryTreeP(B)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>B</code> <code>Graph</code> <p>Graph resolves into <code>G.V</code> and <code>G.E</code>.  Guaranteed to be a binary tree containing Bbt values.</p> required"},{"location":"solutions/q12GetIslandPerimeter/","title":"q12GetIslandPerimeter","text":""},{"location":"solutions/q12GetIslandPerimeter/#solutions.q12GetIslandPerimeter","title":"<code>solutions.q12GetIslandPerimeter</code>","text":""},{"location":"solutions/q12GetIslandPerimeter/#solutions.q12GetIslandPerimeter--question-12-py","title":"Question 12 [PY]","text":"<p>Island Perimeter</p> <p>Given a binary rectangular grid \\(M\\in\\{0,1\\}^{H\\times W}\\) with \\(H\\) rows and \\(W\\) columns, where each pixel \\(m_{ij}\\) represents either \\(0\\) for water or \\(1\\) for land.  Assume that</p> <ol> <li>There\u2019s exactly one island (contiguously connected    land cells);</li> <li>Pixels are connected either vertically or    horizontally but not diagonally; and</li> <li>There are no lakes.</li> </ol> <p>WAP to determine the perimeter of the island!</p> <p>Functions:</p> Name Description <code>q12GetIslandPerimeter</code> <p>Args:</p>"},{"location":"solutions/q12GetIslandPerimeter/#solutions.q12GetIslandPerimeter.q12GetIslandPerimeter","title":"<code>q12GetIslandPerimeter(M)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>M</code> <code>List[List[int]]</code> <p>A list of \\(H\\) lists of \\(W\\) integer values each representing colour at pixel \\((i,j)\\).</p> required"},{"location":"solutions/q13FulfilProgramP/","title":"q13FulfilProgramP","text":""},{"location":"solutions/q13FulfilProgramP/#solutions.q13FulfilProgramP","title":"<code>solutions.q13FulfilProgramP</code>","text":""},{"location":"solutions/q13FulfilProgramP/#solutions.q13FulfilProgramP--question-13-py","title":"Question 13 [PY]","text":"<p>Given \\(N\\) courses labelled \\(\\{0,\\ldots,N-1\\}\\) and a list of prerequisites \\(R\\) such that the courses \\(R[i]\\equiv\\{a_i,b_i,\\ldots\\}\\) are required to be completed before enrolling for \\(i\\)-th course.</p> <p>WAP to determine if all the \\(N\\) courses can be completed successfully by a candidate.  If so, also determine one of the feasible ordering of courses.</p> <p>Examples</p> <ol> <li>\\(N=2\\), \\(R=[\\emptyset,\\{0\\}]\\) means that course \\(1\\)    requires course \\(0\\) as pre-requisite.  Hence, it is    possible to complete the courses, in the following    order: \\([0,1]\\).</li> <li>\\(N=2\\), \\(R=[\\{1\\},\\{0\\}]\\). Here, the requirement is    \\(1\\) before \\(0\\); and also \\(0\\) before \\(1\\).  This,    hence, is impossible.</li> </ol> <p>Functions:</p> Name Description <code>q13FulfilProgramP</code> <p>Args:</p>"},{"location":"solutions/q13FulfilProgramP/#solutions.q13FulfilProgramP.q13FulfilProgramP","title":"<code>q13FulfilProgramP(R)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>R</code> <code>List[List[int]]</code> <p>A list of \\(N\\) lists of integer values where the \\(i\\)-th list represents the reprequisites of \\(i\\).</p> required"},{"location":"solutions/q14GetAllAncestors/","title":"q14GetAllAncestors","text":""},{"location":"solutions/q14GetAllAncestors/#solutions.q14GetAllAncestors","title":"<code>solutions.q14GetAllAncestors</code>","text":""},{"location":"solutions/q14GetAllAncestors/#solutions.q14GetAllAncestors--question-14","title":"Question 14","text":"<p>Given a DAG \\(G(V,E)\\), WAP to determine the list of ancestors for each node.</p> <p>Functions:</p> Name Description <code>q14GetAllAncestors</code> <p>Args:</p>"},{"location":"solutions/q14GetAllAncestors/#solutions.q14GetAllAncestors.q14GetAllAncestors","title":"<code>q14GetAllAncestors(G)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>Graph resolves into <code>G.V</code> and <code>G.E</code>.</p> required"},{"location":"solutions/q15GetCheapestFlight/","title":"q15GetCheapestFlight","text":""},{"location":"solutions/q15GetCheapestFlight/#solutions.q15GetCheapestFlight","title":"<code>solutions.q15GetCheapestFlight</code>","text":""},{"location":"solutions/q15GetCheapestFlight/#solutions.q15GetCheapestFlight--question-15-py","title":"Question 15 [PY]","text":"<p>There are \\(N\\) cities, connected by flights.  Given the list of flights \\(F\\equiv\\{(s_i,d_i,p_i):0&lt;i\\leqslant N\\}\\) so that \\(i\\)-th flight connects the source city \\(s_i\\) to destination city \\(d_i\\) for a cost-price of \\(p_i\\).</p> <p>Given \\(A,B,k\\), WAP to determine the cheapest price to connect city \\(A\\) to city \\(B\\) with maximum \\(k\\) stops.</p> <p></p> <p>Examples (Optimal paths marked in red)</p> <ol> <li>\\(N=4, F\\equiv\\{ (0,1,100), (1,2,100), (2,0,100),    (2,3,200) \\}, A=0, B=3, k=1\\)    Result: \\(700\\)</li> <li>\\(N=3, F\\equiv \\{ (0,1,100), (1,2,100), (0,2,500) \\},    A=0, B=2, k=1\\)    Result: \\(200\\)</li> <li>\\(N=3, F\\equiv \\{ (0,1,100), (1,2,100), (0,2,500) \\},    A=0, B=2, k=0\\)    Result: \\(500\\)</li> </ol> <p>See also: Flight</p> <p>Functions:</p> Name Description <code>q15GetCheapestFlight</code> <p>Args:</p>"},{"location":"solutions/q15GetCheapestFlight/#solutions.q15GetCheapestFlight.q15GetCheapestFlight","title":"<code>q15GetCheapestFlight(F, cityA, cityB, k)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>F</code> <code>List[Flight]</code> <p>List of <code>Flight</code>s.</p> required <code>cityA</code> <code>int</code> <p>Source city.</p> required <code>cityB</code> <code>int</code> <p>Destination city.</p> required <code>k</code> <code>int</code> <p>Num hops permissible in travel.</p> required"},{"location":"solutions/q16DungeonCrossingTimeMin/","title":"q16DungeonCrossingTimeMin","text":""},{"location":"solutions/q16DungeonCrossingTimeMin/#solutions.q16DungeonCrossingTimeMin","title":"<code>solutions.q16DungeonCrossingTimeMin</code>","text":""},{"location":"solutions/q16DungeonCrossingTimeMin/#solutions.q16DungeonCrossingTimeMin--question-16","title":"Question 16","text":"<p>There\u2019s a dungeon arranged as a grid of \\(N\\times M\\) rectangular rooms.</p> <p>\\(T\\in\\mathbb{Z}^{N\\times M}\\) represents for each room \\((i,j)\\), a threshold of minimum time \\(t_{ij}\\) starting from which a move into it may be initiated.</p> <p>Move is allowed only between two adjacent rooms that share a common vertical or horizontal wall, and each move takes 1 unit time duration.</p> <p>WAP to start from room \\((0,0)\\) and finally determine the minimum time required to reach the room \\((N-1,M-1)\\).</p> <p>Examples</p> <ol> <li>\\(T=[[0,4],[4,4]]\\)    Result: \\(6\\)    Explanation: \\(t=4: (0,0)\\to(1,0)\\); \\(t=5: (1,0)\\to(1,1)\\).</li> <li>\\(T=[[0,0,0],[0,0,0]]\\)    Result: \\(3\\)    Explanation: \\(t=0: (0,0)\\to(1,0)\\); \\(t=1: (1,0)\\to(1,1)\\); \\(t=1: (1,1)\\to(1,1)\\).</li> <li>\\(T=[[0,1],[1,2]]\\)    Result: \\(3\\)    Explanation: \\(t=1: (0,0)\\to(1,0)\\); \\(t=2: (1,0)\\to(1,1)\\).</li> </ol> <p>Functions:</p> Name Description <code>q16DungeonCrossingTimeMin</code> <p>Args:</p>"},{"location":"solutions/q16DungeonCrossingTimeMin/#solutions.q16DungeonCrossingTimeMin.q16DungeonCrossingTimeMin","title":"<code>q16DungeonCrossingTimeMin(T)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>T</code> <code>List[List[int]]</code> <p>A list of \\(N\\) lists of \\(M\\) integer values each representing threshold time at room \\((i,j)\\).</p> required"},{"location":"solutions/cli/","title":"CLI Index","text":"<p>Command-line interface scripts available in this module.</p> <ul> <li>add_one</li> </ul>"},{"location":"solutions/cli/add_one/","title":"add_one","text":"<p>Usage:</p> <pre><code>add_one [OPTIONS] NUM\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"}]}